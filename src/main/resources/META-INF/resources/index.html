<!DOCTYPE html>
<html lang="en">
<head>
    <title>BBOP MMO ARCADE</title>
    <meta charset="UTF-8">
    <!-- https://cdn.jsdelivr.net/npm/phaser@3.21.0/dist/phaser-arcade-physics.min.js -->
    <script src="js/phaser-arcade-physics.min.js"></script>
</head>
<body>

<script>

    const DEADZONE_SIZE = 100;

    const HUD_ALPHA = 0.6;
    const HUD_BG = 'black';

    function getCookie(cname) {
        var name = cname + "=";
        var decodedCookie = decodeURIComponent(document.cookie);
        var ca = decodedCookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    }

    function uuidv4() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
        );
    }

    let userIdFromCookie = getCookie("user_id");
    const USER_ID = !userIdFromCookie ? uuidv4() : userIdFromCookie;
    document.cookie = "user_id=" + USER_ID;
    console.log(USER_ID);

    const players = {};

    function gameScene() {
        return game.scene.scenes[0];
    }


    let socket;

    const SHIP_COLOR = [
        0xdd0055,
        0x00aa88,
        0x3333ff,
        0xcc9900,
        0x00a0bb,
        0xaa00ff,
    ];

    function getColorFromShip(ship) {
        if (ship < 0 || ship >= SHIP_COLOR.length) {
            return SHIP_COLOR[SHIP_COLOR.length - 1];
        }
        return SHIP_COLOR[ship];
    }

    function createShip(p) {
        const move = transform.view(p.x, p.y);
        const sprite = gameScene().physics.add.sprite(move.x, move.y, 'ship');
        const color = getColorFromShip(p.ship);
        sprite.setTint(color | 0x555555, color, color | 0x555555, color);
        sprite.setBounce(0, 0);
        sprite.setScale(0.3);
        sprite.setCollideWorldBounds(true);


        sprite.anims.play("ship-rest");

        const wake = {
            _triedAt: -1,
            firedAt: -1,
            sprites: [
                gameScene().physics.add.sprite(-100, -100, 'thrust'),
                gameScene().physics.add.sprite(-100, -100, 'thrust'),
                gameScene().physics.add.sprite(-100, -100, 'thrust'),
                gameScene().physics.add.sprite(-100, -100, 'thrust'),
                gameScene().physics.add.sprite(-100, -100, 'thrust'),
                gameScene().physics.add.sprite(-100, -100, 'thrust'),
                gameScene().physics.add.sprite(-100, -100, 'thrust'),
                gameScene().physics.add.sprite(-100, -100, 'thrust'),
            ],
            nextSprite: 0,

            destroy: () => {
                wake.sprites.forEach(s => s.destroy());
            },

            generate: () => {
                wake._triedAt = Date.now();
                if (wake._triedAt - wake.firedAt > 32) {
                    wake.firedAt = wake._triedAt;
                    wake.sprites[wake.nextSprite].x = sprite.x;
                    wake.sprites[wake.nextSprite].y = sprite.y;
                    wake.sprites[wake.nextSprite].anims.play("thrust");
                    wake.nextSprite = (wake.nextSprite + 1) & 7;
                }
            }
        };

        wake.sprites.forEach(s => {
            s.setDepth(-2).setScale(1).setTint(color).setAlpha(0.7);
        });


        const explosion = {
            sprite: gameScene().physics.add.sprite(-300, -300, 'shockwave'),
            generate: () => {
                explosion.sprite.x = sprite.x;
                explosion.sprite.y = sprite.y;
                explosion.sprite.anims.play("explosion");

            },

            destroy: () => {
                explosion.sprite.destroy();
            },
        };

        explosion.sprite.setDepth(-2).setTintFill(color).setScale(1.5).setAlpha(0.9);


        let str = color.toString(16);
        while (str.length < 6) {
            str = '0' + str;
        }
        str = '#' + str;

        players[p.playerId] = {
            "playerId": p.playerId,
            "color": color,
            "sprite": sprite,
            "colorStyle": str,
            "wake": wake,
            "explosion": explosion,
        }
    }

    const bolts = {};

    const PULSE = [0xfffff, 0x888888, 0x888888, 0x000000];

    function boltMove(b) {
        const move = transform.view(b.x, b.y);
        if (!bolts[b.boltId]) {
            const sprite = gameScene().physics.add.image(move.x, move.y, 'bolt');
            const spritebg = gameScene().physics.add.image(move.x, move.y, 'bolt');

            const owner = players[b.ownerPlayerId];
            if (owner) {
                sprite.setTint(owner.color, owner.color, owner.color, owner.color);
                spritebg.setTint(owner.color, owner.color, owner.color, owner.color);
            }
            sprite.setBounce(0, 0);
            sprite.setScale(0.15);
            sprite.setCollideWorldBounds(true);

            spritebg.setBounce(0, 0);
            spritebg.setScale(1);
            spritebg.setCollideWorldBounds(true);
            spritebg.setDepth(-2);
            spritebg.setAlpha(0.7);

            bolts[b.boltId] = {
                "sprite": sprite,
                "bg": spritebg,
                "color": owner.color,
                "pulsePos": 0
            };
        } else {
            let bolt = bolts[b.boltId];
            bolt.sprite.x = move.x;
            bolt.sprite.y = move.y;
            bolt.bg.x = move.x;
            bolt.bg.y = move.y;
            bolt.sprite.setTint(
                bolt.color | PULSE[bolt.pulsePos],
                bolt.color | PULSE[(bolt.pulsePos + 1) % 4],
                bolt.color | PULSE[(bolt.pulsePos + 2) % 4],
                bolt.color | PULSE[(bolt.pulsePos + 3) % 4],
            );
            bolt.pulsePos = (bolt.pulsePos + 1) % 4;
        }
    }

    const moveQueue = [];
    setInterval(() => {
        const m = {
            "command": "MOVE_PLAYER",
            "moveX": 0,
            "moveY": 0,
        };

        let hasAngle = false;
        for (let evt = moveQueue.shift(); !!evt; evt = moveQueue.shift()) {
            if (evt.move) {
                m.moveX += evt.move.x;
                m.moveY += evt.move.y;
            }
            if (evt.angle) {
                m.angle = evt.angle.value;
                hasAngle = true;
            }
            m.thrustAngle = evt.thrustAngle;
        }
        if (hasAngle || m.moveX !== 0 || m.moveY !== 0) {
            sendMessage(m);
        }
    }, 50);

    function updateScore(resp) {
        if (!players[USER_ID].scoreView) {
            const text = gameScene().add.text(0, 0, '', {fontFamily: 'Verdana, "Times New Roman", Tahoma, serif'});
            text.setScrollFactor(0);
            text.setAlpha(HUD_ALPHA);
            text.setBackgroundColor(HUD_BG);
            text.setColor(players[USER_ID].colorStyle);

            players[USER_ID].scoreView = text;
        }

        players[USER_ID].scoreView.setText(USER_ID.substr(0, 7) + ': ' + resp.score);
        players[USER_ID].scoreView.x = gameScene().game.config.width - (players[USER_ID].scoreView.displayWidth + 5);
    }

    const COMMANDS = {
        'LIST_PLAYERS': resp => {
            resp.players.forEach(createShip);
        },

        'PLAYER_SCORE_UPDATE': updateScore,

    };

    const EVENTS = {

        'PLAYER_JOINED': resp => {
            createShip(resp);

            if (USER_ID === resp.playerId) {
                gameScene().cameras.main.startFollow(players[resp.playerId].sprite, true);
            }
        },

        'PLAYER_MOVED': resp => {
            if (players[resp.playerId]) {
                const sprite = players[resp.playerId].sprite;
                const move = transform.view(resp.x, resp.y);


                if (Math.abs(resp.thrustAngle) <= Math.PI / 4) {
                    setShipThrustAnim(sprite, 'ship-fw');
                } else if (Math.abs(resp.thrustAngle - Math.PI / 2) <= Math.PI / 4) {
                    setShipThrustAnim(sprite, 'ship-left');
                } else if (Math.abs(resp.thrustAngle - Math.PI) <= Math.PI / 4) {
                    setShipThrustAnim(sprite, 'ship-back');
                } else if (Math.abs(resp.thrustAngle + Math.PI / 2) <= Math.PI / 4) {
                    setShipThrustAnim(sprite, 'ship-right');
                }

                players[resp.playerId].wake.generate();

                sprite.x = move.x;
                sprite.y = move.y;

                sprite.setRotation(resp.angle);
            }
        },

        'PLAYER_DESTROYED': resp => {
            if (players[resp.playerId]) {
                const explosion = players[resp.playerId].explosion;

                explosion.generate();
            }
        },

        'PLAYER_LEFT': resp => {
            if (players[resp.playerId]) {
                const sprite = players[resp.playerId].sprite;
                const wake = players[resp.playerId].wake;
                const explosion = players[resp.playerId].explosion;
                sprite.destroy();
                wake.destroy();
                explosion.destroy();
                delete players[resp.playerId];
            }
        },

        'BOLT_MOVED': resp => {
            boltMove(resp)
        },

        'BOLT_EXHAUSTED': resp => {
            if (bolts[resp.boltId]) {
                bolts[resp.boltId].sprite.destroy();
                bolts[resp.boltId].bg.destroy();
                delete bolts[resp.boltId];
            }
        },

        'SCOREBOARD_UPDATED': resp => {
            SCOREBOARD.process(resp);
        },

    };

    function setShipThrustAnim(sprite, toplay) {
        const p = sprite.anims.getProgress();
        if (Number.isNaN(p) || p > 0.9) {
            sprite.anims.play(toplay);
            sprite.anims.chain("ship-rest");
        }
    }

    function setupSocket() {
        socket = new WebSocket("ws://" + location.host + "/game/" + USER_ID);
        socket.onopen = function () {
            console.log("Connected to the web socket");
        };
        socket.onmessage = function (m) {
            console.log("Got message: " + m.data);
            const resp = JSON.parse(m.data);

            const event = EVENTS[resp.event];
            if (event) {
                event(resp);
            }

            const command = COMMANDS[resp.command];
            if (command) {
                command(resp);
            }
        };
    }

    function sendMessage(value) {
        const s = JSON.stringify(value);
        console.log("Sending " + s);
        socket.send(s);
    };


    const config = {
        type: Phaser.AUTO,
        width: window.innerWidth - 20,
        height: window.innerHeight - 20,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: {y: 0},
                isPaused: true
            }
        },
        scene: {
            preload: preload,
            create: create
        }
    };

    const game = new Phaser.Game(config);

    function preload() {
        //this.load.setBaseURL('http://labs.phaser.io');

        this.load.spritesheet('ship', 'assets/ship3-Sheet.png', {frameWidth: 128, frameHeight: 128});
        this.load.spritesheet('thrust', 'assets/thrust3-Sheet.png', {frameWidth: 64, frameHeight: 64});
        this.load.spritesheet('shockwave', 'assets/shockwave1-Sheet.png', {frameWidth: 272, frameHeight: 272});

        this.load.image('bolt', 'assets/white.png');
        this.load.image('wake', 'assets/white.png');

        this.load.image('gridf', 'assets/gridf.png');
        this.load.image('gridb', 'assets/gridb.png');
    }

    const BOUNDS = {
        "min": {
            "x": 0,
            "y": 0,
        },
        "max": {
            "x": 10000,
            "y": 10000
        }
    };

    BOUNDS["width"] = BOUNDS.max.x - BOUNDS.min.x;
    BOUNDS["height"] = BOUNDS.max.y - BOUNDS.min.y;

    BOUNDS["width_float"] = 1.0 * BOUNDS.width;
    BOUNDS["height_float"] = 1.0 * BOUNDS.height;

    const transform = {
        "model": (x, y) => {
            return {
                "x": x / BOUNDS.width_float,
                "y": y / BOUNDS.height_float,
            }
        },
        "view": (x, y) => {
            return {
                "x": x * BOUNDS.width_float, // + BOUNDS.min.x,
                "y": y * BOUNDS.height_float// + BOUNDS.min.y,
            }
        },
    };

    class Scoreboard {
        constructor(scene, width, height, x, y) {
            this.scene = scene;
            this.width = width;
            this.height = height;
            this.x = x;
            this.y = y;
            this.entries = [];


        }

        process(scoreboardUpdatedEvent) {
            scoreboardUpdatedEvent.scores.forEach((entry, i) => {
                if (i >= this.entries.length) {
                    let y = 0;
                    if (i > 0) {
                        y = this.entries[0].displayHeight;
                    }
                    const entry = this.scene.add.text(this.x + 5, this.y + i * y + 2, '', {fontFamily: 'Verdana, "Times New Roman", Tahoma, serif'});
                    entry.setScrollFactor(0);
                    entry.setAlpha(HUD_ALPHA);
                    entry.setBackgroundColor(HUD_BG);
                    this.entries.push(entry);
                }
                this.entries[i].setText(entry.playerId.substr(0, 7) + ": " + entry.score);
                if (players[entry.playerId]) {
                    this.entries[i].setColor(players[entry.playerId].colorStyle);
                } else {
                    this.entries[i].setColor("#ffffff");
                }
            });
        }
    }

    let SCOREBOARD;

    function create() {

        this.cameras.main.setBounds(BOUNDS.min.x, BOUNDS.min.y, BOUNDS.width, BOUNDS.height);
        this.physics.world.setBounds(BOUNDS.min.x, BOUNDS.min.y, BOUNDS.width, BOUNDS.height);


        this.add.image(BOUNDS.min.x, BOUNDS.min.y, 'gridb')
            .setOrigin(0)
            .setScale(1)
            .setDepth(-3);

        this.add.image(BOUNDS.min.x, BOUNDS.min.y, 'gridf')
            .setOrigin(0)
            .setScale(1)
            .setDepth(-1);


        this.cameras.main.setDeadzone(DEADZONE_SIZE, DEADZONE_SIZE);

        SCOREBOARD = new Scoreboard(this, 200, 300, 0, 0);

        setupSocket();


        gameScene().anims.create({
            key: "ship-fw",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 0, end: 1}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-right",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 2, end: 3}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-back",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 4, end: 5}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-left",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 6, end: 7}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-rest",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 8, end: 8}),
            frameRate: 5,
            repeat: 0
        });

        gameScene().anims.create({
            key: "thrust",
            frames: gameScene().anims.generateFrameNumbers('thrust', {start: 0, end: 8}),
            frameRate: 30,
            repeat: 0
        });

        gameScene().anims.create({
            key: "explosion",
            frames: gameScene().anims.generateFrameNumbers('shockwave', {start: 0, end: 8}),
            frameRate: 20,
            repeat: 0
        });

        // Pointer lock will only work after an 'engagement gesture', e.g. mousedown, keypress, etc.
        this.input.on('pointerdown', function (pointer) {

            this.input.mouse.requestPointerLock();

        }, this);


        // When locked, you will have to use the movementX and movementY properties of the pointer
        // (since a locked cursor's xy position does not update)
        this.input.on('pointermove', function (pointer) {

            if (this.input.mouse.locked) {
                const command = {};
                const sprite = players[USER_ID].sprite;

                const moveX = pointer.movementX;
                const moveY = pointer.movementY;

                const x = sprite.x + moveX;
                const y = sprite.y + moveY;

                if (MOVE_CARTESIAN || MOVE_CARTESIAN === MOVE_RADIAL) {
                    command.move = transform.model(pointer.movementX, pointer.movementY);
                }
                if (MOVE_RADIAL || MOVE_CARTESIAN === MOVE_RADIAL) {
                    if (Math.abs(sprite.x - x) > 2 || Math.abs(sprite.y - y) > 2) {
                        command.angle = {
                            "value": Phaser.Math.Angle.Between(sprite.x, sprite.y, x, y) + FORWARD_DIR
                        };
                        command.thrustAngle = FORWARD_DIR;
                    }
                } else if (command.move) {
                    const convDeg = 180 / Math.PI;
                    command.thrustAngle = Phaser.Math.Angle.ShortestBetween(sprite.angle, Phaser.Math.Angle.Between(sprite.x, sprite.y, x, y) * convDeg) / -convDeg;
                }
                moveQueue.push(command);

            }
        }, this);

        // Exit pointer lock when Q is pressed. Browsers will also exit pointer lock when escape is
        // pressed.
        this.input.keyboard.on('keydown_Q', function (event) {
            if (this.input.mouse.locked) {
                this.input.mouse.releasePointerLock();
            }
        }, this);

        let MOVE_CARTESIAN = false;
        let MOVE_RADIAL = false;
        let FORWARD_DIR = 0;

        this.input.keyboard.on('keydown_W', function (event) {
            FORWARD_DIR = 0;
        }, this);
        this.input.keyboard.on('keydown_D', function (event) {
            FORWARD_DIR = Math.PI / 2;
        }, this);
        this.input.keyboard.on('keydown_S', function (event) {
            FORWARD_DIR = Math.PI;
        }, this);
        this.input.keyboard.on('keydown_A', function (event) {
            FORWARD_DIR = Math.PI / -2;
        }, this);

        this.input.keyboard.on('keydown_Z', function (event) {
            MOVE_CARTESIAN = true;
        }, this);
        this.input.keyboard.on('keyup_Z', function (event) {
            MOVE_CARTESIAN = false;
        }, this);

        this.input.keyboard.on('keydown_X', function (event) {
            MOVE_RADIAL = true;
        }, this);
        this.input.keyboard.on('keyup_X', function (event) {
            MOVE_RADIAL = false;
        }, this);

        this.input.keyboard.on('keydown_C', function (event) {
            sendMessage({
                "command": "FIRE_BOLT"
            })
        }, this);


    }
</script>

</body>
</html>
