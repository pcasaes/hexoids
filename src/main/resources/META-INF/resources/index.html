<!DOCTYPE html>
<html lang="en">
<head>
    <title>BBOP MMO ARCADE</title>
    <meta charset="UTF-8">
    <!-- https://cdn.jsdelivr.net/npm/phaser@3.21.0/dist/phaser-arcade-physics.min.js -->
    <script src="js/optional.js"></script>
    <script src="js/phaser-arcade-physics.min.js"></script>
    <script src="js/user-id.js"></script>
    <script src="js/game-config.js"></script>
    <script src="js/uuid.js"></script>
    <script src="js/get-cookie.js"></script>
    <script src="js/hud.js"></script>
    <script src="js/sounds.js"></script>
    <script src="js/server.js"></script>
    <script src="js/transform.js"></script>
    <script src="js/player.js"></script>
    <script src="js/bolts.js"></script>
    <script src="js/scoreboard.js"></script>
    <script src="js/event-queue-consumer.js"></script>
    <script src="js/event-queue-producer.js"></script>
    <script src="js/ai.js"></script>
    <script src="js/bbop.proto.js"></script>
</head>
<body>

<script>


    const USER = new UserId(getCookie, uuid).start();


    const QUEUES = {
        'event': new QueueConsumer('event', 'event'),
        'command': new QueueConsumer('directedCommand', 'command'),
        'move': new QueueProducer(sendMessage).start(),
    };

    function gameScene() {
        return game.scene.scenes[0];
    }

    function getSounds() {
        return Sounds.get(gameScene(), GameConfig.get());
    }

    function getHud() {
        return Hud.get(gameScene(), GameConfig.get());
    }

    const getPlayers = (function () {
        let userSet = false;

        return function () {
            if (userSet) {
                return Players.get(gameScene(), getSounds(), GameConfig.get(), getHud(), transform, QUEUES);
            } else {
                userSet = true;
                return Players.get(gameScene(), getSounds(), GameConfig.get(), getHud(), transform, QUEUES)
                    .follow(USER.get())
                    .addControllableUser(USER.get());
            }
        }
    })();

    function getMyPlayer() {
        return Optional.of(getPlayers().players[USER.get()]);
    }

    function getBolts() {
        return Bolts.get(getServer(), gameScene(), getPlayers(), GameConfig.get(), transform, getSounds(), QUEUES);
    }

    function getServer() {
        return Server.get(USER.get(), QUEUES, location.host, ProtoProcessor);
    }

    function sendMessage(value) {
        getServer().sendMessage(value);
    }


    const config = {
        type: Phaser.AUTO,
        width: window.innerWidth - 20,
        height: window.innerHeight - 20,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: {y: 0},
                isPaused: true
            }
        },
        scene: {
            preload: preload,
            create: create
        }
    };

    const game = new Phaser.Game(config);

    function preload() {
        //this.load.setBaseURL('http://labs.phaser.io');

        this.load.spritesheet('ship', 'assets/ship3-sheet.png', {frameWidth: 128, frameHeight: 128});
        this.load.spritesheet('thrust', 'assets/thrust3-sheet.png', {frameWidth: 64, frameHeight: 64});
        this.load.spritesheet('shockwave', 'assets/shockwave1-sheet.png', {frameWidth: 272, frameHeight: 272});
        this.load.spritesheet('fire-effect', 'assets/fire-effect.png', {frameWidth: 128, frameHeight: 128});

        this.load.atlas('fontatlas', 'assets/font/font2.png', 'assets/font/font2.json');

        this.load.xml('atariXML', 'assets/font/atari-sunset.xml');

        this.load.image('bolt', 'assets/white.png');
        this.load.image('wake', 'assets/white.png');

        this.load.image('gridf', 'assets/gridf.png');
        this.load.image('gridb', 'assets/gridb.png');

        getSounds().get('fire1').preload();
        getSounds().get('explosion1').preload();
        this.load.audio(`death1`, `assets/sound/death1.mp3`);

    }

    const transform = Transform.get(GameConfig.get());


    function create() {

        this.cameras.main.setBounds(GameConfig.get().world.min.x, GameConfig.get().world.min.y, GameConfig.get().world.width, GameConfig.get().world.height);
        this.physics.world.setBounds(GameConfig.get().world.min.x, GameConfig.get().world.min.y, GameConfig.get().world.width, GameConfig.get().world.height);


        this.add.image(GameConfig.get().world.min.x, GameConfig.get().world.min.y, 'gridb')
            .setOrigin(0)
            .setScale(1)
            .setDepth(GameConfig.get().add('background.depth', -2));

        this.add.image(GameConfig.get().world.min.x, GameConfig.get().world.min.y, 'gridf')
            .setOrigin(0)
            .setScale(1)
            .setDepth(GameConfig.get().background.depth);


        this.cameras.main.setDeadzone(GameConfig.get().camera.deadZone, GameConfig.get().camera.deadZone);

        //create singletons
        getPlayers();
        getBolts();
        getServer();

        Scoreboard.get(this, getPlayers(), 0, 0)
            .setAlpha(GameConfig.get().hud.alpha)
            .setupEventQueue(QUEUES.event)
            .setDepth(GameConfig.get().hud.depth);

        Phaser.GameObjects.BitmapText.ParseFromAtlas(this, 'font', 'fontatlas', 'atari-sunset', 'atariXML');


        (function (game) {
            const EMPTY_OBJ = {};
            // Pointer lock will only work after an 'engagement gesture', e.g. mousedown, keypress, etc.
            game.input.on('pointerdown', function (pointer) {

                game.input.mouse.requestPointerLock();

            }, game);


            // When locked, you will have to use the movementX and movementY properties of the pointer
            // (since a locked cursor's xy position does not update)
            game.input.on('pointermove', function (pointer) {

                if (game.input.mouse.locked) {
                    getMyPlayer().ifPresent(p => p.move(pointer, MOVE_CARTESIAN, MOVE_RADIAL, FORWARD_DIR));
                }
            }, game);

            // Exit pointer lock when Q is pressed. Browsers will also exit pointer lock when escape is
            // pressed.
            game.input.keyboard.on('keydown_Q', function (event) {
                if (game.input.mouse.locked) {
                    game.input.mouse.releasePointerLock();
                }
            }, game);

            game.input.keyboard.on('keydown_SPACE', function (event) {
                getMyPlayer().ifPresent(p => {
                    if (!p.ship.sprite.active) {
                        sendMessage({
                            "spawn": EMPTY_OBJ
                        })
                    }
                });
            }, game);

            let MOVE_CARTESIAN = false;
            let MOVE_RADIAL = false;
            let FORWARD_DIR = 0;

            game.input.keyboard.on('keydown_W', function (event) {
                FORWARD_DIR = 0;
            }, game);
            game.input.keyboard.on('keydown_D', function (event) {
                FORWARD_DIR = Math.PI / 2;
            }, game);
            game.input.keyboard.on('keydown_S', function (event) {
                FORWARD_DIR = Math.PI;
            }, game);
            game.input.keyboard.on('keydown_A', function (event) {
                FORWARD_DIR = Math.PI / -2;
            }, game);

            game.input.keyboard.on('keydown_Z', function (event) {
                MOVE_CARTESIAN = true;
            }, game);
            game.input.keyboard.on('keyup_Z', function (event) {
                MOVE_CARTESIAN = false;
            }, game);

            game.input.keyboard.on('keydown_X', function (event) {
                MOVE_RADIAL = true;
            }, game);
            game.input.keyboard.on('keyup_X', function (event) {
                MOVE_RADIAL = false;
            }, game);

            game.input.keyboard.on('keydown_C', function (event) {
                getBolts().fire();
            }, game);

        })(this);


        const AI = (function () {
            const urlParams = new URLSearchParams(window.location.search);
            if ('true' === urlParams.get('ai')) {
                return new AiBot(USER.get(), getServer(), getPlayers(), transform, GameConfig.get());
            }
            return {
                'start': () => {
                }, 'stop': () => {
                }
            };
        })();
        AI.start();
    }


</script>

</body>
</html>
