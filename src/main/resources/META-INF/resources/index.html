<!DOCTYPE html>
<html lang="en">
<head>
    <title>BBOP MMO ARCADE</title>
    <meta charset="UTF-8">
    <!-- https://cdn.jsdelivr.net/npm/phaser@3.21.0/dist/phaser-arcade-physics.min.js -->
    <script src="js/phaser-arcade-physics.min.js"></script>
    <script src="js/user-id.js"></script>
    <script src="js/game-config.js"></script>
    <script src="js/uuid.js"></script>
    <script src="js/get-cookie.js"></script>
    <script src="js/player.js"></script>
    <script src="js/bolts.js"></script>
    <script src="js/scoreboard.js"></script>
    <script src="js/event-queue.js"></script>
    <script src="js/ai.js"></script>
</head>
<body>

<script>


    const USER = new UserId(getCookie, uuid).start();

    function gameScene() {
        return game.scene.scenes[0];
    }


    let socket;

    function getPlayers() {
        return Players.get(gameScene(), GameConfig.get(), USER.get(), transform, QUEUES);
    }

    function getBolts() {
        return Bolts.get(gameScene(), getPlayers(), GameConfig.get(), transform, QUEUES);
    }

    const moveQueue = [];
    setInterval(() => {
        const m = {
            "command": "MOVE_PLAYER",
            "moveX": 0,
            "moveY": 0,
        };

        let hasAngle = false;
        for (let evt = moveQueue.shift(); !!evt; evt = moveQueue.shift()) {
            if (evt.move) {
                m.moveX += evt.move.x;
                m.moveY += evt.move.y;
            }
            if (evt.angle) {
                m.angle = evt.angle.value;
                hasAngle = true;
            }
            m.thrustAngle = evt.thrustAngle;
        }
        if (hasAngle || m.moveX !== 0 || m.moveY !== 0) {
            sendMessage(m);
        }
    }, 50);

    const COMMAND_Q = new EventQueue('command');


    const EVENT_Q = new EventQueue('event');

    const QUEUES = {
        'event': EVENT_Q,
        'command': COMMAND_Q,
        'move': moveQueue
    };


    function setupSocket() {
        socket = new WebSocket("ws://" + location.host + "/game/" + USER.get());
        socket.onopen = function () {
            console.log("Connected to the web socket");
        };
        socket.onmessage = function (m) {
            console.log("Got message: " + m.data);
            const resp = JSON.parse(m.data);
            EVENT_Q.consume(resp);
            COMMAND_Q.consume(resp);
        };
    }

    function sendMessage(value) {
        const s = JSON.stringify(value);
        console.log("Sending " + s);
        socket.send(s);
    };


    const config = {
        type: Phaser.AUTO,
        width: window.innerWidth - 20,
        height: window.innerHeight - 20,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: {y: 0},
                isPaused: true
            }
        },
        scene: {
            preload: preload,
            create: create
        }
    };

    const game = new Phaser.Game(config);

    function preload() {
        //this.load.setBaseURL('http://labs.phaser.io');

        this.load.spritesheet('ship', 'assets/ship3-sheet.png', {frameWidth: 128, frameHeight: 128});
        this.load.spritesheet('thrust', 'assets/thrust3-sheet.png', {frameWidth: 64, frameHeight: 64});
        this.load.spritesheet('shockwave', 'assets/shockwave1-sheet.png', {frameWidth: 272, frameHeight: 272});
        this.load.spritesheet('fire-effect', 'assets/fire-effect.png', {frameWidth: 128, frameHeight: 128});

        this.load.atlas('fontatlas', 'assets/font/font2.png', 'assets/font/font2.json');

        this.load.xml('atariXML', 'assets/font/atari-sunset.xml');

        this.load.image('bolt', 'assets/white.png');
        this.load.image('wake', 'assets/white.png');

        this.load.image('gridf', 'assets/gridf.png');
        this.load.image('gridb', 'assets/gridb.png');
    }

    const transform = {
        "model": (x, y) => {
            return {
                "x": x / GameConfig.get().world.width_float,
                "y": y / GameConfig.get().world.height_float,
            }
        },
        "view": (x, y) => {
            return {
                "x": x * GameConfig.get().world.width_float,
                "y": y * GameConfig.get().world.height_float
            }
        },
    };


    function create() {

        this.cameras.main.setBounds(GameConfig.get().world.min.x, GameConfig.get().world.min.y, GameConfig.get().world.width, GameConfig.get().world.height);
        this.physics.world.setBounds(GameConfig.get().world.min.x, GameConfig.get().world.min.y, GameConfig.get().world.width, GameConfig.get().world.height);


        this.add.image(GameConfig.get().world.min.x, GameConfig.get().world.min.y, 'gridb')
            .setOrigin(0)
            .setScale(1)
            .setDepth(GameConfig.get().add('background.depth', -2));

        this.add.image(GameConfig.get().world.min.x, GameConfig.get().world.min.y, 'gridf')
            .setOrigin(0)
            .setScale(1)
            .setDepth(GameConfig.get().background.depth);


        this.cameras.main.setDeadzone(GameConfig.get().camera.deadZone, GameConfig.get().camera.deadZone);

        Scoreboard.get(this, getPlayers(), 0, 0)
            .setAlpha(GameConfig.get().hud.alpha)
            .setupEventQueue(EVENT_Q)
            .setDepth(GameConfig.get().hud.depth);

        getPlayers();
        getBolts();

        setupSocket();

        Phaser.GameObjects.BitmapText.ParseFromAtlas(this, 'font', 'fontatlas', 'atari-sunset', 'atariXML');


        gameScene().anims.create({
            key: "ship-fw",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 0, end: 1}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-right",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 2, end: 3}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-back",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 4, end: 5}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-left",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 6, end: 7}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-rest",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 8, end: 8}),
            frameRate: 5,
            repeat: 0
        });

        gameScene().anims.create({
            key: "thrust",
            frames: gameScene().anims.generateFrameNumbers('thrust', {start: 0, end: 8}),
            frameRate: 30,
            repeat: 0
        });

        gameScene().anims.create({
            key: "explosion",
            frames: gameScene().anims.generateFrameNumbers('shockwave', {start: 0, end: 8}),
            frameRate: 20,
            repeat: 0
        });

        gameScene().anims.create({
            key: "fire-bolt",
            frames: gameScene().anims.generateFrameNumbers('fire-effect', {start: 0, end: 3}),
            frameRate: 15,
            repeat: 0
        });


        // Pointer lock will only work after an 'engagement gesture', e.g. mousedown, keypress, etc.
        this.input.on('pointerdown', function (pointer) {

            this.input.mouse.requestPointerLock();

        }, this);


        // When locked, you will have to use the movementX and movementY properties of the pointer
        // (since a locked cursor's xy position does not update)
        this.input.on('pointermove', function (pointer) {

            if (this.input.mouse.locked) {
                if (getPlayers().myPlayer) {
                    getPlayers().myPlayer.move(pointer, MOVE_CARTESIAN, MOVE_RADIAL, FORWARD_DIR)
                }
            }
        }, this);

        // Exit pointer lock when Q is pressed. Browsers will also exit pointer lock when escape is
        // pressed.
        this.input.keyboard.on('keydown_Q', function (event) {
            if (this.input.mouse.locked) {
                this.input.mouse.releasePointerLock();
            }
        }, this);

        let MOVE_CARTESIAN = false;
        let MOVE_RADIAL = false;
        let FORWARD_DIR = 0;

        this.input.keyboard.on('keydown_W', function (event) {
            FORWARD_DIR = 0;
        }, this);
        this.input.keyboard.on('keydown_D', function (event) {
            FORWARD_DIR = Math.PI / 2;
        }, this);
        this.input.keyboard.on('keydown_S', function (event) {
            FORWARD_DIR = Math.PI;
        }, this);
        this.input.keyboard.on('keydown_A', function (event) {
            FORWARD_DIR = Math.PI / -2;
        }, this);

        this.input.keyboard.on('keydown_Z', function (event) {
            MOVE_CARTESIAN = true;
        }, this);
        this.input.keyboard.on('keyup_Z', function (event) {
            MOVE_CARTESIAN = false;
        }, this);

        this.input.keyboard.on('keydown_X', function (event) {
            MOVE_RADIAL = true;
        }, this);
        this.input.keyboard.on('keyup_X', function (event) {
            MOVE_RADIAL = false;
        }, this);

        this.input.keyboard.on('keydown_C', function (event) {
            sendMessage({
                "command": "FIRE_BOLT"
            })
        }, this);


        const AI = (function () {
            const urlParams = new URLSearchParams(window.location.search);
            if ('true' === urlParams.get('ai')) {
                return new AiBot(USER.get(), getPlayers(), GameConfig.get());
            }
            return {
                'start': () => {
                }, 'stop': () => {
                }
            };
        })();
        AI.start();
    }


</script>

</body>
</html>
