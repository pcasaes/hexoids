<!DOCTYPE html>
<html lang="en">
<head>
    <title>BBOP MMO ARCADE</title>
    <meta charset="UTF-8">
    <!-- https://cdn.jsdelivr.net/npm/phaser@3.21.0/dist/phaser-arcade-physics.min.js -->
    <script src="js/phaser-arcade-physics.min.js"></script>
    <script src="js/user-id.js"></script>
    <script src="js/game-config.js"></script>
    <script src="js/uuid.js"></script>
    <script src="js/get-cookie.js"></script>
    <script src="js/player.js"></script>
    <script src="js/scoreboard.js"></script>
    <script src="js/event-queue.js"></script>
    <script src="js/ai.js"></script>
</head>
<body>

<script>


    const USER = new UserId(getCookie, uuid).start();

    const PLAYERS = {};

    function gameScene() {
        return game.scene.scenes[0];
    }


    let socket;


    const bolts = {};

    const PULSE = [0xfffff, 0x888888, 0x888888, 0x000000];

    function boltMove(b) {
        const move = transform.view(b.x, b.y);
        if (!bolts[b.boltId]) {
            const sprite = gameScene().physics.add.image(move.x, move.y, 'bolt');
            const spritebg = gameScene().physics.add.image(move.x, move.y, 'bolt');

            const owner = PLAYERS[b.ownerPlayerId];
            if (owner) {
                sprite.setTint(owner.ship.color, owner.ship.color, owner.ship.color, owner.ship.color);
                spritebg.setTint(owner.ship.color, owner.ship.color, owner.ship.color, owner.ship.color);
                owner.ship.fireBolt.generate();
            }
            sprite.setBounce(0, 0);
            sprite.setScale(0.15);
            sprite.setDepth(GameConfig.get().add('ship.depth', 1));
            sprite.setCollideWorldBounds(true);

            spritebg.setBounce(0, 0);
            spritebg.setScale(1);
            spritebg.setCollideWorldBounds(true);
            spritebg.setDepth(GameConfig.get().background.effectsDepth);
            spritebg.setAlpha(0.7);


            bolts[b.boltId] = {
                "sprite": sprite,
                "bg": spritebg,
                "color": owner.ship.color,
                "pulsePos": 0
            };
        } else {
            let bolt = bolts[b.boltId];
            bolt.sprite.x = move.x;
            bolt.sprite.y = move.y;
            bolt.bg.x = move.x;
            bolt.bg.y = move.y;
            bolt.sprite.setTint(
                bolt.color | PULSE[bolt.pulsePos],
                bolt.color | PULSE[(bolt.pulsePos + 1) % 4],
                bolt.color | PULSE[(bolt.pulsePos + 2) % 4],
                bolt.color | PULSE[(bolt.pulsePos + 3) % 4],
            );
            bolt.pulsePos = (bolt.pulsePos + 1) % 4;
        }
    }

    const moveQueue = [];
    setInterval(() => {
        const m = {
            "command": "MOVE_PLAYER",
            "moveX": 0,
            "moveY": 0,
        };

        let hasAngle = false;
        for (let evt = moveQueue.shift(); !!evt; evt = moveQueue.shift()) {
            if (evt.move) {
                m.moveX += evt.move.x;
                m.moveY += evt.move.y;
            }
            if (evt.angle) {
                m.angle = evt.angle.value;
                hasAngle = true;
            }
            m.thrustAngle = evt.thrustAngle;
        }
        if (hasAngle || m.moveX !== 0 || m.moveY !== 0) {
            sendMessage(m);
        }
    }, 50);

    function updateScore(resp) {
        PLAYERS[USER.get()].updateScore(resp);
    }

    const COMMAND_Q = new EventQueue('command')
        .add('LIST_PLAYERS', resp => {
            resp.players.forEach(r => PLAYERS[r.playerId] = Player.create(gameScene(), GameConfig.get(), transform, r));
        })
        .add('PLAYER_SCORE_UPDATE', updateScore);


    const EVENT_Q = new EventQueue('event')
        .add('PLAYER_JOINED', resp => {
            PLAYERS[resp.playerId] = Player.create(gameScene(), GameConfig.get(), transform, resp);

            if (USER.get() === resp.playerId) {
                PLAYERS[resp.playerId].setMoveQueue(moveQueue);
                gameScene().cameras.main.startFollow(PLAYERS[resp.playerId].ship.sprite, true);
            }
        })
        .add('PLAYER_MOVED', resp => {
            if (PLAYERS[resp.playerId]) {
                const sprite = PLAYERS[resp.playerId].ship.sprite;
                const move = transform.view(resp.x, resp.y);


                if (Math.abs(resp.thrustAngle) <= Math.PI / 4) {
                    setShipThrustAnim(sprite, 'ship-fw');
                } else if (Math.abs(resp.thrustAngle - Math.PI / 2) <= Math.PI / 4) {
                    setShipThrustAnim(sprite, 'ship-left');
                } else if (Math.abs(resp.thrustAngle - Math.PI) <= Math.PI / 4) {
                    setShipThrustAnim(sprite, 'ship-back');
                } else if (Math.abs(resp.thrustAngle + Math.PI / 2) <= Math.PI / 4) {
                    setShipThrustAnim(sprite, 'ship-right');
                }

                PLAYERS[resp.playerId].ship.wake.generate();

                PLAYERS[resp.playerId].ship.moveTo(move.x, move.y, resp.angle);
            }
        })
        .add('PLAYER_DESTROYED', resp => {
            if (PLAYERS[resp.playerId]) {
                PLAYERS[resp.playerId].ship.explosion.generate();
            }
        })
        .add('PLAYER_LEFT', resp => {
            if (PLAYERS[resp.playerId]) {
                PLAYERS[resp.playerId].destroy();
                delete PLAYERS[resp.playerId];
            }
        })
        .add('BOLT_MOVED', resp => {
            boltMove(resp)
        })
        .add('BOLT_EXHAUSTED', resp => {
            if (bolts[resp.boltId]) {
                bolts[resp.boltId].sprite.destroy();
                bolts[resp.boltId].bg.destroy();
                delete bolts[resp.boltId];
            }
        });

    function setShipThrustAnim(sprite, toplay) {
        const p = sprite.anims.getProgress();
        if (Number.isNaN(p) || p > 0.9) {
            sprite.anims.play(toplay);
            sprite.anims.chain("ship-rest");
        }
    }

    function setupSocket() {
        socket = new WebSocket("ws://" + location.host + "/game/" + USER.get());
        socket.onopen = function () {
            console.log("Connected to the web socket");
        };
        socket.onmessage = function (m) {
            console.log("Got message: " + m.data);
            const resp = JSON.parse(m.data);
            EVENT_Q.consume(resp);
            COMMAND_Q.consume(resp);
        };
    }

    function sendMessage(value) {
        const s = JSON.stringify(value);
        console.log("Sending " + s);
        socket.send(s);
    };


    const config = {
        type: Phaser.AUTO,
        width: window.innerWidth - 20,
        height: window.innerHeight - 20,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: {y: 0},
                isPaused: true
            }
        },
        scene: {
            preload: preload,
            create: create
        }
    };

    const game = new Phaser.Game(config);

    function preload() {
        //this.load.setBaseURL('http://labs.phaser.io');

        this.load.spritesheet('ship', 'assets/ship3-sheet.png', {frameWidth: 128, frameHeight: 128});
        this.load.spritesheet('thrust', 'assets/thrust3-sheet.png', {frameWidth: 64, frameHeight: 64});
        this.load.spritesheet('shockwave', 'assets/shockwave1-sheet.png', {frameWidth: 272, frameHeight: 272});
        this.load.spritesheet('fire-effect', 'assets/fire-effect.png', {frameWidth: 128, frameHeight: 128});

        this.load.atlas('fontatlas', 'assets/font/font2.png', 'assets/font/font2.json');

        this.load.xml('atariXML', 'assets/font/atari-sunset.xml');

        this.load.image('bolt', 'assets/white.png');
        this.load.image('wake', 'assets/white.png');

        this.load.image('gridf', 'assets/gridf.png');
        this.load.image('gridb', 'assets/gridb.png');
    }

    const BOUNDS = {
        "min": {
            "x": 0,
            "y": 0,
        },
        "max": {
            "x": 10000,
            "y": 10000
        }
    };

    BOUNDS["width"] = BOUNDS.max.x - BOUNDS.min.x;
    BOUNDS["height"] = BOUNDS.max.y - BOUNDS.min.y;

    BOUNDS["width_float"] = 1.0 * BOUNDS.width;
    BOUNDS["height_float"] = 1.0 * BOUNDS.height;

    const transform = {
        "model": (x, y) => {
            return {
                "x": x / BOUNDS.width_float,
                "y": y / BOUNDS.height_float,
            }
        },
        "view": (x, y) => {
            return {
                "x": x * BOUNDS.width_float, // + BOUNDS.min.x,
                "y": y * BOUNDS.height_float// + BOUNDS.min.y,
            }
        },
    };


    function create() {

        this.cameras.main.setBounds(BOUNDS.min.x, BOUNDS.min.y, BOUNDS.width, BOUNDS.height);
        this.physics.world.setBounds(BOUNDS.min.x, BOUNDS.min.y, BOUNDS.width, BOUNDS.height);


        this.add.image(BOUNDS.min.x, BOUNDS.min.y, 'gridb')
            .setOrigin(0)
            .setScale(1)
            .setDepth(GameConfig.get().add('background.depth', -2));

        this.add.image(BOUNDS.min.x, BOUNDS.min.y, 'gridf')
            .setOrigin(0)
            .setScale(1)
            .setDepth(GameConfig.get().background.depth);


        this.cameras.main.setDeadzone(GameConfig.get().camera.deadZone, GameConfig.get().camera.deadZone);

        Scoreboard.get(this, PLAYERS, 0, 0)
            .setAlpha(GameConfig.get().hud.alpha)
            .setupEventQueue(EVENT_Q)
            .setDepth(GameConfig.get().hud.depth);

        setupSocket();

        Phaser.GameObjects.BitmapText.ParseFromAtlas(this, 'font', 'fontatlas', 'atari-sunset', 'atariXML');


        gameScene().anims.create({
            key: "ship-fw",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 0, end: 1}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-right",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 2, end: 3}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-back",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 4, end: 5}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-left",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 6, end: 7}),
            frameRate: 5,
            repeat: 1
        });

        gameScene().anims.create({
            key: "ship-rest",
            frames: gameScene().anims.generateFrameNumbers('ship', {start: 8, end: 8}),
            frameRate: 5,
            repeat: 0
        });

        gameScene().anims.create({
            key: "thrust",
            frames: gameScene().anims.generateFrameNumbers('thrust', {start: 0, end: 8}),
            frameRate: 30,
            repeat: 0
        });

        gameScene().anims.create({
            key: "explosion",
            frames: gameScene().anims.generateFrameNumbers('shockwave', {start: 0, end: 8}),
            frameRate: 20,
            repeat: 0
        });

        gameScene().anims.create({
            key: "fire-bolt",
            frames: gameScene().anims.generateFrameNumbers('fire-effect', {start: 0, end: 3}),
            frameRate: 15,
            repeat: 0
        });

        // Pointer lock will only work after an 'engagement gesture', e.g. mousedown, keypress, etc.
        this.input.on('pointerdown', function (pointer) {

            this.input.mouse.requestPointerLock();

        }, this);


        // When locked, you will have to use the movementX and movementY properties of the pointer
        // (since a locked cursor's xy position does not update)
        this.input.on('pointermove', function (pointer) {

            if (this.input.mouse.locked) {
                const player = PLAYERS[USER.get()];
                if (player) {
                    player.move(pointer, MOVE_CARTESIAN, MOVE_RADIAL, FORWARD_DIR)
                }
            }
        }, this);

        // Exit pointer lock when Q is pressed. Browsers will also exit pointer lock when escape is
        // pressed.
        this.input.keyboard.on('keydown_Q', function (event) {
            if (this.input.mouse.locked) {
                this.input.mouse.releasePointerLock();
            }
        }, this);

        let MOVE_CARTESIAN = false;
        let MOVE_RADIAL = false;
        let FORWARD_DIR = 0;

        this.input.keyboard.on('keydown_W', function (event) {
            FORWARD_DIR = 0;
        }, this);
        this.input.keyboard.on('keydown_D', function (event) {
            FORWARD_DIR = Math.PI / 2;
        }, this);
        this.input.keyboard.on('keydown_S', function (event) {
            FORWARD_DIR = Math.PI;
        }, this);
        this.input.keyboard.on('keydown_A', function (event) {
            FORWARD_DIR = Math.PI / -2;
        }, this);

        this.input.keyboard.on('keydown_Z', function (event) {
            MOVE_CARTESIAN = true;
        }, this);
        this.input.keyboard.on('keyup_Z', function (event) {
            MOVE_CARTESIAN = false;
        }, this);

        this.input.keyboard.on('keydown_X', function (event) {
            MOVE_RADIAL = true;
        }, this);
        this.input.keyboard.on('keyup_X', function (event) {
            MOVE_RADIAL = false;
        }, this);

        this.input.keyboard.on('keydown_C', function (event) {
            sendMessage({
                "command": "FIRE_BOLT"
            })
        }, this);


    }

    const AI = (function () {
        const urlParams = new URLSearchParams(window.location.search);
        if ('true' === urlParams.get('ai')) {
            return new AiBot(USER.get());
        }
        return {
            'start': () => {
            }, 'stop': () => {
            }
        };
    })();
    AI.start();

</script>

</body>
</html>
